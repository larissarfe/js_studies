
--------> JS ENGINE AND RUNTIME 

WHAT IS THAT ENGINE ACTUALLY?
AND WHAT IS A JS RUNTIME? 
HOW IS JS CODE TRANSLATED TO A MACHINE CODE? 

1 - THE JS ENGINE IS SIMPLY A COMPUTER PROGRAM THAT EXECUTES JS CODE - THERE ARE A LOR OF STEPS INVOLVED IN DOING THAT 
BUT ESSENTIALLY EXECUTING JS CODE IS WHAT AN ENGINE DOES. 

EVERY BROWSER HAS ITS OWN JS ENGINE BUT PROBABLY THE MOST WELL KNOW ENGINE IS GOOGLE'S V-EIGHT 

RESUMINDO-------> A JS ENGINE IS A PROGRAM THAT EXECUTES JS AND ALL BWOSER HAVE THEY OWN!!! 

----0000---000---->>>>> JS ENGINE COMPONENTS::: 

ANY JS ENGINE ALWAYS CONTAINS A CALL STACK AND A HEAP 

A) CALL STACK -> IS WHERE OUR CODE IS ACTUALLY EXECUTED USING SOMETHING CALLED EXECUTION CONTEXTS 

B) HEAP ---> IS AN UNSTRUCTURED MEMORY POOL WHICH STORES ALL THE OBJECTS THAT OUR APPLICATION NEEDS 

-- BUT HOW THE CODE IS COMPILED TO MACHINE CODE SO THAT IT CAN ACTUALLY BE EXECUTED AFTERWARDS? 

VERY IMPORTAAAAAAANNNNNNTTTTT ::::::::>>>>>>>>>

EVERY COMPUTER PROGRAM NEEDS TO BE CONVERTED INTO MACHINE CODE - ZEROS AND ONES 

- AND THIS CAN HAPPEN USING COMPILATION OR INTERPRETATION 

----> IN COMPILATION THE ENTIRE SOURCE CODE IS CONVERTED INTO MACHINE CODE AT ONCE AND THIS MACHINE CODE IS THEN WRITTEN INTO A PORTABLE FILE
THAT CAN BE EXECUTED ON ANY COMPUTER 

SO THERE ARE 2 STEPS IN COMPILATION:

1- SOURCE CODE ---> COMPILATION ------> PORTABLE FILE

2. PORTABLE FILE -------> EXECUTION ------> PROGRAM RUNNING 

SO COMPILATION::: ENTIRE CODE IS CONVERTED INTO MACHINE CODE AT ONCE, AND WRITTEN TO A BINARY FILE THAT CAN BE EXECUTED BY A COMPUTER 


IMP: THE EXECUTION CAN HAPPEN WAY AFTER COMPILATION 

------->>> INTERPRETATION: 

INTERPERTER RUNS THROUGH THE SOURCE CODE AND EXECUTES IT LINE BY LINE 

HERE WE DO NOT HAVE THE SAME 2 STEPS AS BEFORE 

1. SOURCE CODE -------> EXECUTION LINE BY LINE --------> PROGRAM RUNNING

THE CODE IS READ AND EXECUTED ALL AT THE SAME TIME!!!!!!!!!!!! 

OF COURSE THE SOURCE CODE STILL NEEDS TO BE CONVERTED INTO MACHINE CODE BUT IT SIMPLY HAPPENS RIGHT BEFORE IT'S EXECUTED 

THE PROBLEM WITH INTERPRETED LANGUAGES IS THAT THEY ARE MUCH SLOWER THAN COMPILED LANGUAGES 

JS USED TO BY A FULLY INTERPRETED LANGUAGE 

SO INSTEAD OF SIMPLE INTERPRETATION, MODERN JS ENGINE NOW USE A MIX BETWEEN COMPILATION AND INTERPRETATION WHICH IS CALLED JUST IN TIME 
COMPILATION 

-------> JUST IN TIME COMPILATION (JIT) -> ENTIRE CODE IS CONVERTED INTO MACHINE CODE AT ONCE THEN EXECUTED IMMEDIATELY 

SO WE STILL HAVE THE 2 STEPS OF REGULAR AHEAD OF TIME COMPILATION BUT THERE'S NO PORTABLE FILE TO EXECUTE 

AND THE EXECUTION HAPPENS IMMEDIATELY AFTER A COMPILATION 

SO HOW IT WORKS INSIDE THE JS ENGINE::::::

JS CODE ------> PARSING (AST) - BASICALLY IS READ ------> JUST IN TIME COMPILATION --------> EXECUTION (HAPPENS IN CALL STACK)

NEW JS ENGINE - HAVE SOME PRETTY CLEVER OPTIMIZATION STRATEGIES -> WHAT THEY DO IS TO CREATE A VERY UNOPTIMIZED VERSION OF MACHINE CODE IN THE BEGINNING  
JUST SO THAT IT CAN START EXECUTING AS FAST AS POSSIBLE 

THEN IN THE BACKGROUND THIS CODE IS BEING OPTIMIZED AND RECOMPILED DURING THE ALREADY RUNNING PROGRAM EXECUTION

AND THIS CAN BE DONE MULTIPLE TIMES!!!!!!!!!!!!!! 

AND AFTER EACH OPTIMIZATION THE UNOPTIMIZED CODE IS SIMPLY SWEPT FOR THE NEW MORE OPTIMIZED CODE WITHOUT EVER STOPPING EXECUTION OF COURSE 

ALL THIS PARSING, COMPILATION AND OPTIMIZATION HAPPENS IN SOME SPECIAL THREADS INSIDE THE ENGINE THAT WE CANNOT EXCESS FROM OUR CODE --
SO COLETELY SEPARATED FROM THE MAIN THREAD THAT IS BASICALLY RUNNING IN THE CALL STACK EXECUTING OUR OWN CODE 



----------> WHAT A JS RUNTIME IS????
 

    THE MOST COMMON ONE IS THE BROWSER

    WE CAN IMAGINE JS RUNTIME AS A BIG BOX OR A BIG CONTAINER WHICH INCLUDES ALL THE THINGS WE NEED TO USE JS (IN THIS CASE IN THE BROWSER)

    - THE HEART OF EVERY JS RUNTIME IS ALWAYS A JS ENGINE


IN ORDER TO WORK PROPERLY WE ALSO NEED ACCESS TO THE WEB API'S -----

    WEB API'S ARE ESSENCIALLY FUNTIONALITIES PROVIDED TO THE ENGINE BUT WHICH ARE ACTUALLY NOT PART OF JS LANGUAGE ITSELF 

    API'S -> FUNTIONALITIES PROVIDED TO THE ENGINE, ACCESSIBLE ON WINDOW OBJECT 

BUT IT STILL MAKES SENSE THAT THE WEB APIS ARE ALSO PART OF THE RUNTIME - BECAUSE A RUNTIME IS JUST LIKE A BOX THAT CONTAINS ALL THE JS RELATED STUFF WE NEED 


A TYPICAL JS RUNTIME ALSO INCLUDES A SO CALLED CALLBACK QUEUE 

CALLBACK QUEUE IS A DATA STRUCTURE THAT CONTAINS ALL THE CALLBACK FUNTIONS THAT ARE READY TO BE EXECUTED - FOR EX 
    WE ATTACH EVENT HANDLER FUNTIONS TO DOM ELEMENTS LIKE A BUTTON TO REACT TO CERTAIN EVENTS 

    AND THESE EVENT HANDLER FUNTIONS ARE ALSO CALLED CALLBACK FUNCTIONS 

    AS THE EVENT HAPPENS  - THE CALLBACK FUNCTION WILL BE CALLED 

    EVENT LOOP -> TAKES CALLBACK FUNCTIONS FROM THE CALLBACK QUEUE AND PUTS THEM IN THE CALL STACK SO THAT THEY CAN BE EXECUTED 

    THE EVENT LOOP IS  HOW JS NONBLOCKING CONCURRENCY MODEL IS IMPLEMENTED


JS CAN EXISTS OUTSIDE THE BROWSERS 

THE BROWSER THAT PROVIDES THE WEB APIS 

OBS --- CALLBACK QUEUE::: CLICK, TIMER, DATA, ....