
----------- > PRIMITIVES VS OBJECTS IN PRACTICE 

//----------- > PRIMITIVES VS OBJECTS IN PRACTICE




let lastName = 'Willian';

let oldLastName = lastName;

lastName = 'Davis'; // HERE WE MUTADED THE VARIABLE

console.log(lastName, oldLastName); // --- Davis Willian

//-- IT WORKS THIS WAY BECAUSE EACH PRIMITIVE VALUE WILL SIMPLY BE SAVED INTO ITS OWN PIECE OF MEMORY IN THE STACK

// NOW DOING THE SAME THING WITH AN OBJECT - WHICH IS A REFERENCE VALUE

// BECAUSE IT IS GOING TO BE STORED IN THE HEAP AND THE STACK THEN JUST KEEPS A REFERENCE TO THE MEMORY POSITION AT WHICH THE OBJECT IS STORED IN THE HEAP

const jessica = {
  firstName: 'Jessica',
  lastName: 'Williams',
  age: 27,
};

const marriedJessica = jessica; // HERE WE ARE NOT COPYNG THE OBJECT WE ARE COPING THE REFERENCE WHICH WILL THEN POINT TO THE SAME OBJECT

marriedJessica.lastName = 'Davis';

console.log('Before marriage:', jessica);
console.log('After marriage:', marriedJessica);

////////////const array = [1, 2, 3];

///////array = [1, 2, 3, 4];

///////console.log(array);

//--------------------- duvidaaaaaaaaaaaaa

// THE OUTPUT IS GOING TO BE 'DAVIS' AS LAST NAME FOR BOTH OBJECTS

// THAT HAPPENED BECAUSE WHEN WE ATTEMPTED TO COPY THE ORIGINAL JESSICA OBJECT IT DID IN FACT NOT CREATED A NEW OBJECT IN THE HEAP

// SO marriedJessica IS NOT A NEW OBJECT IN THE HEAP, IT'S SIMPLY JUST ANOTHER VARIABLE IN THE STACK WHICH HOLDS THE REFERENCE TO THE ORIGINAL OBJECT

// SO BOTH OS THESE VARIABLES POINT TO THE EXACTLY SAME MEMORY ADDRESS IN THE HEAP

// AND THAT'S BECAUSE IN THE STACK, THEY BOTH HOLD THE SAME MEMORY ADDRESS REFERENCE

// SO IF WE CHANGE A PROPERTY IN THE MARRIED JESSICA OBJECT IT WILL ALSO BE CHANGED IN THE OBJECT JESSICA ITSELF, SINCE THEY ARE USING THE SAME ADDRESS REFERENCE

// BECAUSE ESSENTIALY THEY ARE JUST TWO DIFFERENT NAMES FOR THE SAME THING

// WE USED CONST TO DECLARE THIS OBJECT BUT EVEN SO WE COULD CHANGE IT'S PROPERTY. WHY?

// BECAUSE WE USE CONST FOR THINGS WE CANNOT CHANGE - HOWEVER WHAT ACTUALLY NEEDS TO BE CONSTANT IS THE VALUE IN THE STACK

// AND IN THIS STACK, THE VALUE ONLY HOLDS THE REFERENCE, WHICH WE ARE NOT ACTUALLY CHANGING

// THE ONLY THING THAT WE ARE CHANGING IS THE UNDERLYING (SUBJACENTE) OBJECT THAT IS STORED IN THE HEAP - AND THAT IS OK TO CHANGE

// IT HAS NOTHING TO DO WITH CONST OR LET!!!!!!!!!!!

// WHAT WE CAN'T DO IS ASSIGN A COMPLETELY DIFFERENT OBJECT NOW TO MARRIED JESSICA EX:

// marriedJessica = {}

// THIS WILL NOT WORK BECAUSE THIS NEW OBJECT WILL BE STORED AT A DIFFERENT POSITION IN MEMORY, AND THEREFORE THE REFERENCE TO THAT POSITION IN MEMORY

// WILL HAVE TO CHANGE!!!!!!!!!

///>>>>>>>>>>>>>>>>> IN CONCLUSION, COMPLETELY CHANGING THE OBJECT - SO, ASSIGNING A NEW OBJECT TO IT IS COMPLETELY DIFFERENT THAN SIMPLY CHANGING A PROPERTY

// ---======---======= WHAT IF WE ACTUALLY REALLY WANTED TO COPY THE OBJECT SO THAT WE COULD THEN CHANGE ONE OF THEM WITHOUT CHANGING THE OTHER???

// ------COPYING OBJECTS:::::

// WE COULD USE A FUNCTION THAT MERGES TWO OBJECTS INTO A DIFFERENT ONE:

const jessica2 = {
  firstName: 'Jessica',
  lastName: 'Williams',
  age: 27,
  family: ['Alice', 'Bob'],
};

const jessicaCopy = Object.assign({}, jessica2); // --------> THIS FUNCTION WILL MERGE AN EMPTY OBJECT WITH JESSICA2 RESULTING IN A NEW OBJECT

jessicaCopy.lastName = 'Davis';

console.log(jessica2, jessicaCopy);

jessicaCopy.family.push('Mary');

jessicaCopy.family.push('John');

// THE JESSICACOPY IS NOW A REAL COPY OF THE ORIGINAL

// HOWEVER THERE'S STILL A PROBLEMA BECAUSE USING THIS TECHNIQUE OF OBJECT.ASSIGN ONLY WORKS ON THE FIRST LEVEL

// OR IN OTHER WORDS, IF WE HAVE AN OBJECT INSIDE OF THE OBJECT - THEN THIS INNER OBJECT WILL ACTUALLY STILL BE THE SAME -> IT WILL STILL POINT TO THE SAME PLACE IN MEMORY

// THATS WHY WE SAY THAT THIS FUNCTION OBJECT.ASSIGN ONLY CREATED A SHALLOW COPY AND NOT A DEEP CLONE WHICH IS WHAT WE WOULD HAVE LIKE TO HAVE

// >>>>> A SHALLOW COPY WILL ONLY COPY THE PROPERTIES IN THE FIRST LEVEL WHILE A DEEP CLONE WOULD COPY EVERYTHING

// IF E CREATE AN ARRAY INSIDE OF JESSICA2 :

//const jessica2 = {
// firstName: 'Jessica',
// lastName: 'Williams',
// age: 27,
//family: ['Alice', 'Bob'],
// };

//- THIS NEW PROPERTY (ARRAY) WILL ALSO BE CREATE IN THE COPY JESSICACOPY

// IF WE WANT TO ADD MORE FAMILY MEMBERS TO JESSICACOPY IT WILL NOT WORK ALSO, IT WILL ADD TO THE ORIGINAL OBJECT JESSICA2, WHICH IS NOT WHAT WE WANTED

// SO BOTH JESSICA 2 AND JESSICACOPY HAVE THIS PROPERTY FAMILY WHICH POINTS AT THE SAME OBJECT IN THE MEMORY HEAP - AN ARRAY

// SO IF WE CHANGE IT IN ONE IT WIL ALSO BE CHANGED IN THE OTHER
