
--------------------->>>> PRIMITIVE VS OBJECTS (PRIMITIVE VS REFERENCE TYPES)

PRIMITIVES ARE LIKE NUMBERS, STRINGS, BOOLEANS, ETC. 

let age = 30;

let oldAge = age;

age = 31; 

console.log(age); --------> 31
console.log(oldAge); --------> 30 

THE AGE VARIABLE GOT UPDATED AND THE OLD AGE VARIABLE WAS PRESERVED 

BECAUSE IT WAS SET IN THE SPECIFIC POINT IN THE CODE LIKE let oldAge = age; WHILE THE AGE WAS 30 

AND SO THEN CHANGING THE AGE FROM 30 TO 31 DID NOT AFFECT THE OLD AGE VARIABLE!!!!! - BECAUSE AT THE POINT THE VARIABLE oldAge WAS DECLARED THE AGE WAS STIÇÇ 30 

------ NOW WITH AN OBJECT:

const me = {
    name: 'Jonas',
    age: 30
}

const friend = me;

friend.age = 27; 

THE ME AGE WILL CHANGE TO 27 TOO WHY'S THAT???? 

--------------- JS PRIMITIVES DATA TYPES: 

1. NUMBER;
2. STRING;
3. BOOLEAN;
4. UNDEFINED;
5. NULL;
6. SYMBOL;
7. BigInt

------- THEN EVERYTHING ELSE ARE BASICALLY OBJECTS:

1. OBJECT LITERAL - OBJECTS CREATED WITH THE OBJECT LITERAL

2. ARRAYS;

3. FUNCTIONS;

4. MANY MORE...

WHEN WE TALK ABOUT MEMORY AND MEMORY REFERENCE WE CALL THE PRIMITIVES LIKE PRIMITIVE TYPES AND OBJECTS AS REFERENCE TYPES 

BECAUSE OF THE DIFFERENT WAY THEY ARE STORED IN MEMORY. 

THE ENGINE HAS TWO COMPONENTS: 

1. THE CALL STACK - WHERE FUNCTIONS ARE EXECUTED 

2. THE HEAP - WHERE OBJECTS ARE STORED IN MEMORY 

SO ALL OBJECTS, BUT IN ANOTHER WORDS, REFERENCE TYPES WILL GET STORED IN THE MEMORY HEAP

ON THE OTHER WAY AROUND, PRIMITIVES OR PRIMITIVE TYPES ARE STORED IN THE CALL STACK 

    SO PRIMITIVE TYPES ARE STORED IN THE EXECUTION CONTEXTS IN WHICH THEY ARE DECLARED 



let age = 30;

let oldAge = age;

age = 31; 

console.log(age); --------> 31
console.log(oldAge); --------> 30  

WHAT HAPPENS WITH THIS PIECE OF CODE? 

THE FIRST THING JS WILL DO IS TO CREATE A SO-CALLED UNIQUE IDENTIFIER WITH THE VARIABLE NAME 

THEN A PIECE OF MEMORY WILL BE ALLOCATED WITH A CERTAIN ADDRESS (EX: 0001);

THEN FINALLY THE VALUE WILL BE STORED IN THE MEMORY AT THE SPECIFIED ADDRESS

    THIS ALL HAPPENS IN THE CALL STACK WHERE PRIMITIVE VALUES ARE STORED 

    IMPORTANT TO NOTICE THAT THE IDENTIFIER ACTUALLY POINTS TO THE ADDRESS AND NOT TO THE VALUE ITSELF 

    FOR JS AGE IS EQUAL TO THE MEMORY ADDRESS 0001 AND NOT THE VALUE 30!!! 


    let oldAge = age; - KNOWING THAT A VARIABLE ACTUALLY HOLDS A MEMORY ADDRESS

    oldAge WILL SIMPLY POINT TO THE SAME MEMORY ADDRESS AS THE AGE VARIABLE - SO oldAge WILL LOOK LIKE 30 AS WELL 

    age = 31;  

    WHEN WE SET AGE TO A NEW VALUE, THE VALUE AT THE ADDRESS 0001 WILL CERTAINLY NOT BECOME 31!!!!! BECAUSE THAT WOULD CHANGE THE OLD AGE AS WELL SINCE THEY BOTH POINT TO THE SAME ADDRESS

    ALSO ----------- THE VALUE AT A CERTAIN MEMORY ADDRESS IS IMMUTABLE!!!!!

    INSTEAD A NEW PIECE OF MEMORY IS ALLOCATED (CREATED) AND THE AGE IDENTIFIER NOW SIMPLY POINTS TO THE NEW ADDRESS WHICH IS HOLDING THE NEW VALUE OF 31 

__----------------------------------------------_____________________________________________----------------------------------___________________________________________ 

const me = {
    name: 'Jonas',
    age: 30
}

const friend = me;

friend.age = 27; 


what happens to this piece of code? 

WHEN A NEW OBJECT IS CREATED SUCH AS THE ME OBJECT - IT IS STORED IN THE HEAP 

AND JUST LIKE BEFORE, THERE'S A MEMORY ADDRESS AND THEN THE VALUE ITSELF 

    NOW IN THE CASE OF REFERENCE VALUES - THE ME IDENTIFIER DOES ACTUALLY NOT POINT DIRECTLY TO THIS NEWLY CREATED MEMORY ADDRESS IN THE HEAP 

    INSTEAD, IT WILL POINT TO A NEW PIECE OF MEMORY THAT'S CREATED IN THE STACK - AND THIS NEW PIECE OF MEMORY WILL THEN POINT TO THE OBJECT THAT'S IN THE HEAP BY USING THE MEMORY ADDRESS AS ITS VALUE 

    IN OTHER WORDS, THE PIECE OF MEMORY IN THE CALL STACK HAS A REFERENCE TO THE PIECE OF MEMORY IN THE HEAP WHICH HOLDS THE ME OBJECT 

    AND THAT'S THE REASON WE CALL OBJECTS REFERENCE TYPES 

    > SO WHEN WE DECLARE A VARIABLE AS AN OBJECT AN IDENTIFIER IS CREATED WHICH POINTS TO A PIECE OF MEMORY IN THE STACK WHICH TURNS TO PIECE OF MEMORY 
    IN THE HEAP - AND THAT'S WHERE THE OBJECT IS ACTUALLY STORED 


    IT WORKS THIS WAY BECAUSE OBJECTS MICHT BE TOO LARGE TO BE STORED IN THE STACK - INSTEAD THEY ARE STORED IN THE HEAP, WHICH IS LIKE AN ALMOST UNLIMITED MEMORY POOL 


AS MUCH AS WE DECLARED THE FRIEND VARIABLE WITH CONST WE STILL CAN SET A NEW VALUE TO THE PROPERTY. BECAUSE WE'RE NOT CHANGING THE VALUE AT THE ADRESS IN THE CALL STACK 


>>>>>>>>>>>>>>>>>>>>>>> VARIABLES DECLARED WITH CONST ARE ONLY IMMUTABLE IF WE ARE TALKING ABOUT PRIMITIVE VALUES  BUT NOT FOR REFERENCE TYPES 


