

-------> SUPPOSING THAT OUR CODE WAS JUST FINISHED COMPILING::

- SO THE CODE IS NOW READY TO BE EXECUTED 

- WHAT HAPPENS THEN IS THAT A SO CALLED GLOBAL EXECUTION CONTEXT IS CREATED FOR THE TOP LEVEL CODE 

COMPILING ------> CREATING OF GLOBAL EXECUTION CONTEXT (FOR TOP LEVEL CODE)


-- AND TOP LEVEL CODE IS BASICALLY CODE THAT IS NOT THAT IS NOT INSIDE ANY FUNCTION

TOP LEVEL CODE = CODE THAT IS NOT INSIDE ANY FUNCTION 

----======> SO IN THE BEGINNING ONLY THE CODE THAT IS OUTSIDE OF THE FUNCTIONS WILL BE EXECUTED 

AND IT MAKES SENSE BECAUSE FUNCTIONS SHOULD ONLY BE EXECUTED WHEN THEY ARE CALLED 

ANY VARIABLE DECLAREDED OUTSIDE OF THE FUNCTION IS TOP LEVEL CODE THEREFORE IT WILL BE EXECUTED IN THE GLOBAL EXECUTION CONTEXT 

THE CODE INSIDE OF THE FUNCTIONS WILL ONLY BE EXECUTED WHEN THE FUNCTIONS ARE CALLED 

THE GLOBAL EXECUTION CONTEXT IS CREATED FOR TOP LEVEL CODE 

BUT WHAT EXACTLY IS AN EXECUTION CONTEXT?  

    EXECUTION CONTEXT IS AN ABSTRACT CONCEPT 

--> EXECUTION CONTEXT = ENVIROMENT IN WHICH A PIECE OF JS IS EXECUTED. STORES ALL THE NECESSARY INFORMATION FOR SOME CODE TO BE EXECUTED 

--- SO JS CODE ALWAYS RUNS INSIDE AN EXECUTION CONTEXT 

-- IN ANY JS CODE, NO MATTER HOW LARGE IT IS, THERE'S ONLY ONE GLOBAL EXECUTION CONTEXT -> IT'S ALWAYS THERE AS THE DEFAULT CONTEXT AND IT'S WHERE TOP LEVEL CODE (NOT INSIDE A FUNCTION) WILL EXECUTE 

-- THEN THERE'S THE EXECUTION OF THE TOP LEVEL CODE 

- WHEN THE TOP LEVEL CODE EXECUTION IS FINISHED - FUNCTIONS FINALLY START TO EXECUTE AS WELL 

----- AND HOW DOES IT WORK? ONE EXECUTION PER FUNTION - SO FOR EACH FUNCTION CALL, A NEW EXECUTION CONTEXT WILL BE CREATED CONTAINING ALL THE INFORMATION THAT IS NECESSARY TO RUN EXACTLY THAT FUNCTION


----- ALL THESE EXECUTION CONTEXT TOGETHER MAKE UP THE CALL STACK 

---> WHEN ALL FUNCTIONS ARE DONE EXECUTING THE ENGINE WILL BASICALLY KEEP WAITING FOR CALLBACK FUNCTIONS TO ARRIVE 


================> WHAT'S INSIDE AN EXECUTION CONTEXT? 



1- VARIABLE ENVIRONMENT 
- IT'S SO CALLED VARIABLE ENVIRONMENT: - IN THIS ENVIRONMENT

>>>>>>>>>>>>> ALL THE VARIABLES AND FUNCTIONS DECLARATIONS ARE STORED AND THERE'S ALSO A SPECIAL ARGUMENTS OBJECT (ALL THE ARGUMENTS THAT WERE PASSED INTO THE FUNCTION THAT THE CURRENT EXECUTION CONTEXT BELONGS TO)

2- SCOPE CHAIN - CONSISTS IN REFERENCES TO VARIABLES THAT ARE LOCATED OUTSIDE OF THE CURRENT FUNCTION - AND TO KEEP TRACK OF THE SCOPE CHAIN - IT IS STORES IN EACH EXECUTION CONTEXT - 
EACH CONTEXT ALSO GETS A SPECIAL VARIABLE CALLED THE THIS KEYWORD 

3- THIS KEYWORD 

THESE 3 ELEMENTS THAT FORM THE EXECUTION CONTEXT ARE GENERATED DURING "CREATION PHASE" RIGHT BEFORE THE EXECUTION 

ONE MORE DETAIL:::: EXECUTION CONTECTS BELONGING TO ARROW FUNCTIONS DO NOT GET THEIR OWN ARGUMENTS KEYWORD NOR DO THEY GET THE THIS KEYWORD 

SO ARROW FUNCTIONS DO NOT HAVE THE ARGUMENTS OBJECT NOR THE HIS KEYWORD 

>>> INSTEAD, THEY CAN USE THE ARGUMENTS OBJECT AND THE THIS KEYWORD FROM THEIR CLOSEST FUNCTION PARENT 

--> WHAT IS THE CALL STACK: IT'S BASICALLY A PLACE WHERE EXECUTION CONTEXTS GET STACKED ON TOP OF EACH OTHER IN ORDER TO KEEP TRACK OF WHERE WE ARE IN THE PROGRAM'S EXECUTION
  SO THE EXECUTION CCONTEXT THAT AIS ON THE TOP AT THE STACK IS THE ONE THAT IS CURRENTLY RUNNING 

AND WHEN IT'S FINISHED RUNNING IT WILL BE REMOVED FROM THE STACK AND EXECUTION WILL GO BACK TO THE PREVIOUS EXECUTION CONTEXT 

JS HAS ONLY ONE THREAD OF EXECUTION SO IT CAN DO ONLY ONE THING AT TIME - CALL STACK 

ONCE THE FUNCTION RETURN WITH THE RETURN KEYWORD THEN THE FUNCTION IN THE CALL STACK WILL BE POPPED OFF AND DESAPPEAR FROM THE COMPUTER'S MEMORY 

AFTER THE EXECUTION CONTEXT BE POPPED OFF, THE PREVIOUS EXECUTION CONTEXT WILL NOW BE BACK TO BEIGN THE ACTIVE EXECUTION CONTEXT AGAIN. 

WITHOUT THE CALL STACK HOW WOULD THE ENGINE KNOW WHAT FUNCTION WAS BEING EXECUTED BEFORE? - IT WOULDN'T KNOW WHAT TO GO BACK TO 

THE CALL STACK ENSURES THAT THE ORDER OF EXECUTION NEVER GETS LOST 

IMP ------> THE CODE RUNS IN THE CALL STACK 

