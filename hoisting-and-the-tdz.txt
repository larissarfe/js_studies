

-------> VARIABLE ENVIROMENT - HOISTING AND THE TZD 

EXECUTION CONTEXTS ALWAYS CONTAINS 3 PARTS: 

1) VARIABLE ENVIROMENT

2) SCOPE CHAIN - IN THE CURRENT CONTEXT 

3) THIS KEYWORD 


-========----=====---===

1- VARIABLE ENVIROMENT: 

     IN JS WE HAVE A MECHANISM CALLED HOISTING 

     AND HOISTING BASICALLY MAKES SOME TYPES OF VARIABLES ACCESSIBLE/USABLE IN THE CODE BEFORE THEY ARE ACTUALLY DECLARED 

     "VARIABLES LIFTED TO THE TOP OF THEIR SCOPE" - SOME SAY THAT'S WHAT HAPPENS BUT BEHIND THE SCENES::::::::

     BEFORE EXECUTION, CODE IS SCANNED FOR VARIABLES DECLARATIONS, AND FOR EACH VARIABLE, A NEW PROPERTY IS CREATED IN THE VARIABLE ENVIROMENT OBJECT 

    THEN FOR EACH VERIABLE THAT IS FOUND IN THE CODE A NEW PROPERTY IS CREATED

------- HOISTING DOES NOT LOOK THE SAME FOR ALL VARIABLE TYPES 

--> HOW HOISTING WORKS FOR:

1- FUNCTION DECLARATIONS, --> ARE HOISTED AND THE INITIAL VALUE IN THE VARIABLE ENVIROMENT IS SET TO THE ACTUAL FUNCTION - 
    IT MEANS THAT WE CAN USE FUNCTION DECLARATIONS BEFORE THEY ARE ACTUALLY DECLARED IN THE CODE 

    BECAUSE THEY ARE STORED IN THE VARIABLE ENVIROMENT OBJECT EVEN BEFORE THE CODE ESTARTS EXECUTING 
    FUNCTIONS DECLARATIONS ARE BLOCK SCOPE ----> THIS IS ONLY TRUE FOR STRICT MODE 




2- VARIABLES DEFINED WITH VAR ----> THEY ARE ALSO HOISTED, BUT HOISTING WORKS IN A DIFFERENT WAY HERE.

UNLIKE FUNCTIONS, WHEN WE TRY TO ACCESS A VAR VARIBLE BEFORE IT'S DECLARED IN A CODE WE DON'T GET THE DECLARED VALUE BUT WE GET UNDEFINED 



3- VARIABLES DEFINED WITH LET AND CONST ----- LET AND CONST VARIABLES ARE NOT HOISTED (TECHNICALLY YES BUT NOT IN PRACTICE) 
TECHNICALLY HTEY ARE ACTUALLY HOISTED BUT THEIR VALUE IS BASICALLY SET TO AN INITIALIZED - SO THERE'S NO VALUE TO WORK WITH AT ALL 
SO IN PRACTICE IS LIKE HOISTING IS NOT HAPPENING AT ALL; 

INSTEAD, WE SAY THAT THESE VARIABLES ARE PLACED IN A SO CALLED TEMPORAL DEAD ZONE OR TDZ -> WHICH MAKES IT SO THAT WE CAN'T ACCESS THE VARIABLES BETWEEN THE BEGINNING OF THE SCOPE AND THE PLACE WHERE THE VARIABLES ARE DECLARED 
SO IF WE ATTEMPT TO USE A LET OR CONST VARIABLE BEFORE IT'S DECLARED, WE GET AN ERROR  

ALSO LET AND CONST ARE BLOCK SCOPED SO THEY ONLY EXIST IN THE BLOCK WHICH THEY WERE CREATED 



4- FUNCTIONS EXPRESSIONS AND ARROWS --->  IT DEPENDS IF THEY WERE CREATED USING VAR OR CONST OR LET - KEEP IN MY THAT THESE FUNCTIONS ARE SIMPLY VARIABLES 

SO THEY BEHAVE THE EXACT SAME WAY AS VARIABLES IN REGARDS TO HOISTING

SO WE CANNOT USE FUNCTION EXPRESSIONS BEFORE WE WRITE THEM IN THE CODE UNLIKE FUNCTIONS DECLARATIONS


===================================> TEMPORAL DEAD ZONE, LET AND CONST 

const MyName = 'Jonas';

if (myName === 'Jonas') {
    console.log(`Jonas is a ${job}`); 
    const age = 2037 - 1989;
    console.log(age);
    const job = 'teacher';
    console.log(x);

}

----> THE VARIABLE JOB IS A CONST SO IT'S SCOPED ONLY TO THIS IF BLOCK AND IT'S GOING TO BE ACCESSIBLE 
STARTING FROM THE LINE WHERE IT'S DEFINED ---- WHY????? THE TEMPORAL DEAD ZONE BEFORE THE VARIABLE DECLARATION IS NOT ACCESSIBLE 

IT'S BASICALLY THE REGION OF THE SCOPE IN WHICH THE VARIABLE IS DEFINED BUT CAN'T BE USED IN ANY WAY - SO IT IS AS IF THE VARIABLE DIDN'T EVEN EXIST

SO EACH AND EVERY LET AND CONST VARIABLE GET THEIR OWN TDZ THAT STARTS AT THE BEGINNING OF THE SCOPE UNTIL THE LINE WHERE IT IS DEFINED 
    AND THE VARIABLE IS ONLY SAFE TO USE AFTER THE TDZ 


THE TDZ EXISTS THEN TO MAKE IT EASIER YO AVOID AND CATCH ERRORS

BECAUSE USING A VARIABLE THAT IS SET TO UNDEFINED BEFORE IT'S ACTUALLY DECLARED CAN CAUSE SERIOUS BUGS WHICH MIGHT BE HARD TO FIND 

---> SO ACCESSING VARIBLES BEFORE DECLARATION IS BAD PRACTICE AND SHOULD BE AVOIDED 

CONST SHOULD NEVER BE REASSIGNED SO IT'S ONLY ASSIGNED WHEN EXECUTION ACTUALLY REACHES THE DECLARATION 
AND THAT MAKES IMPOSSIBLE TO USE THE VARIABLE BEFORE 

=================> SO WHY HOISTING? 

SO WE CAN USE FUNCTION DECLARATIONS BEFORE WE USE THEM 






